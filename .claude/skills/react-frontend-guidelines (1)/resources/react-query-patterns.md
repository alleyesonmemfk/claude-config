# React Query Patterns (Orval)

## Auto-Generated Hooks

```typescript
// front/src/shared/api/generated/items/items.ts
// Auto-generated by Orval - DO NOT edit manually!

export const useGetCategories = (options?: UseQueryOptions<...>) => {
  return useQuery({
    queryKey: ['categories'],
    queryFn: () => api.get('/api/v2/categories/'),
    ...options
  });
};

export const useSearchItems = (params: SearchParams, options?: UseQueryOptions<...>) => {
  return useQuery({
    queryKey: ['items', params],
    queryFn: () => api.get('/api/v2/items/search', { params }),
    ...options
  });
};
```

## Using Queries in Component

```typescript
// front/src/pages/Items/ui/ItemsPage.tsx
import { useState } from 'react';
import { useGetCategories, useSearchItems } from 'shared/api/generated/items/items';
import { Loading } from 'shared/components/Loading';

export const ItemsPage: FC = () => {
  const [searchQuery, setSearchQuery] = useState('');

  // Query for categories
  const { data: categories, isLoading: categoriesLoading } = useGetCategories();

  // Query for search (conditional)
  const { data: items, isLoading: itemsLoading } = useSearchItems(
    { query: searchQuery },
    { enabled: searchQuery.length > 2 } // Only executes if > 2 characters
  );

  if (categoriesLoading) {
    return <Loading />;
  }

  return (
    <div>
      <input
        value={searchQuery}
        onChange={(e) => setSearchQuery(e.target.value)}
        placeholder="Search items..."
      />

      {itemsLoading ? (
        <Loading />
      ) : (
        <div>
          {items?.data.map(item => (
            <div key={item.id}>{item.title}</div>
          ))}
        </div>
      )}
    </div>
  );
};
```

## Patterns Checklist

- Use auto-generated hooks from `shared/api/generated/`
- Destructure `{ data, isLoading, error }`
- `enabled` for conditional queries
- Loading states for UX
- Error handling

## Mutations

```typescript
import { useCreateItemMutation } from 'shared/api/generated/items/items';
import { useQueryClient } from '@tanstack/react-query';

export const CreateItemForm: FC = () => {
  const queryClient = useQueryClient();

  const { mutate: createItem, isPending, isError, error } = useCreateItemMutation({
    onSuccess: () => {
      // Invalidate cache for refetch
      queryClient.invalidateQueries({ queryKey: ['items'] });
      showNotification('Item created!', 'success');
    },
    onError: (error) => {
      showNotification(error.message, 'error');
    }
  });

  const handleSubmit = (data: CreateItemData) => {
    createItem({ data });
  };

  return (
    <form onSubmit={handleSubmit}>
      {isError && <div className={styles.error}>{error.message}</div>}
      {/* form fields */}
      <Button type="submit" loading={isPending}>Create</Button>
    </form>
  );
};
```

## Optimistic Updates

```typescript
const { mutate: toggleComplete } = useUpdateItemMutation({
  onMutate: async (newItem) => {
    // Cancel outgoing refetches
    await queryClient.cancelQueries({ queryKey: ['items'] });

    // Snapshot previous value
    const previousItems = queryClient.getQueryData(['items']);

    // Optimistically update
    queryClient.setQueryData(['items'], (old: Item[]) =>
      old.map(item =>
        item.id === newItem.id ? { ...item, ...newItem } : item
      )
    );

    return { previousItems };
  },
  onError: (err, newItem, context) => {
    // Rollback on error
    queryClient.setQueryData(['items'], context?.previousItems);
  },
  onSettled: () => {
    // Refetch after mutation
    queryClient.invalidateQueries({ queryKey: ['items'] });
  },
});
```

## Infinite Queries (Pagination)

```typescript
import { useInfiniteQuery } from '@tanstack/react-query';

export const useInfiniteItems = () => {
  return useInfiniteQuery({
    queryKey: ['items-infinite'],
    queryFn: ({ pageParam = 0 }) =>
      api.get('/api/v2/items', { params: { skip: pageParam, limit: 20 } }),
    getNextPageParam: (lastPage, pages) => {
      if (lastPage.data.length < 20) return undefined;
      return pages.length * 20;
    },
    initialPageParam: 0,
  });
};

// Usage
const { data, fetchNextPage, hasNextPage, isFetchingNextPage } = useInfiniteItems();

const allItems = data?.pages.flatMap(page => page.data) ?? [];
```

## Query with Debounce

```typescript
import { useDebounce } from 'shared/hooks/useDebounce';

export const SearchComponent: FC = () => {
  const [searchTerm, setSearchTerm] = useState('');
  const debouncedSearchTerm = useDebounce(searchTerm, 500);

  const { data, isLoading } = useSearchQuery(
    { query: debouncedSearchTerm },
    { enabled: debouncedSearchTerm.length > 2 }
  );

  return (
    <div>
      <input
        value={searchTerm}
        onChange={e => setSearchTerm(e.target.value)}
        placeholder="Search..."
      />
      {isLoading && <Loading />}
      {data?.map(item => <Item key={item.id} {...item} />)}
    </div>
  );
};
```

## Generate API Client

```bash
# Generate from OpenAPI
npm run api:generate

# Auto-generate on changes
npm run api:watch
```
